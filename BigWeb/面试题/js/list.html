<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
</body>
<script>
//=======================对象基础=========================||

let obja = {},
    objb = "0",
    objc = 0;
obja[objb] = 'val1';
obja[objc] = 'val2';
console.log(obja[objb]) //val2 对象的key中 "0" 和 0 是一样的

// ====================

let a = {},
    b = {
        bb: '1'
    },
    c = {
        cc: '2'
    }

a[b] = 1; // a["[object object]"] = 1 所有对象做为key都会被转 [object object]
a[c] = 2;
console.log(a[b]) //2

//=============js将对象自动转字符串的过程========
let obj = {
    a: 4,
    toString() {
        return 'aaa'
    },
}
console.log(obj) //可以打印任何书籍类型
//alert(obj) //只能打印字符串. 自身优先 -> 构造函数prototype -> Object的toString [object object]

function Myobj(name) {
    this.name = name;
    this.toString = function(){
     return 'bbb'
    }
}
Myobj.prototype.toString = function() {
    return 'ccc'
}
let obj1 = new Myobj('obj1')
// alert(obj1)

//=============怎么能让a==1&&a==2&&a==3  ========
/*
    对象 == 字符串 对象.toString()转字符串
    null == undefined 但是和其他值比较就不相等了
    NaN == NaN 不相等
    其他比较都转数字
*/
// 方法1 重写对象toString,valueOf方法
var objdxxx ={
    val:1,
    toString(){ //valueOf也可以
        return this.val++
    }
}

//方法2 使用数据劫持实现
var obje = 1;
Object.defineProperty(window, "objd", {
    get(){
        return obje++
    }
});

if(objd==1&&objd==2&&objd==3){
    console.log('可以')
}


//=======================运行机制=========================||

/*
    执行上下文:
    函数外
        定义var变量与函数(函数名与变量名相同会被覆盖)
        主线程执行程序
    函数中
        形参赋值
        定义变量与函数
        主线程执行程序

    浏览器线程-任务列队-事件循环:
    浏览器多线程，只会给js一个线程,所有js是单线程
    运行首先执行主线程，当遇到Promise或定时器时会丢到任务列队(Event Quque)里,继续执行主线程的内容
    主线程完了才会走任务列队的微任务(await，Promise等)，再走宏任务(Ajax、定时器,事件绑定等),宏任务完了就运行结束了
    主线程执行完后去找一个个的微宏任务，找到一个拿到主线程继续执行执行完再去找。。。，就叫做Event Loop事件循环
*/

//=======================闭包=========================||

/*
    闭包
    闭包就是外面函数中return 新函数地址,使新函数在外面可以使用，新函数中可以使用外面函数的变量
*/

//=======================跨域=========================||
/*
    http 默认 80, https 默认 443, ftp 默认 21
    协议域名端口号都要相同
    浏览器同源策略，不同源之间不能进行访问(前后端分离之前情况不多，分离后前端开发时开的服务一般与后端或线上的域不一样，导致跨域普遍增多)

    阶段一：jsonp
    使用script标签无跨域原理，通过get请求，与后端协商在传的src路经上指定一个我页面上本存在的方法，引入时直接调用，页面直接可以拿到传来的数据了
    服务端接到src时，开始准备数据，通过说好的方法如:　'func({...})' 返回过来，浏览器会直接把这个执行
    缺点: get不安全、有缓存、大小限制、后端支持

    阶段二: iframe 也很不方便不好

    阶段三: CORS跨域资源共享
    后端开启资源共享，但是会设置类似token的东西,保证获取数据的安全，不会别人调用
    前端:
        准备好baseURL、请求头信息等准备发送请求
        请求拦截器:在登入成功后,服务端通过算法(如JWT)生成token，返回前端存到本地储存或store存起来，发送请求的时候都要带上(可以在请求拦截中设置)
                  axios.interceptors.request.use...
                  后端拿到token后再经过同样的方法生成token哪里对比，一样合法则可以通过
        相应拦截器:拿到数据后在这里出来，调用错误，或可以调用状态不对，直接提示问题,成功则通过返回到页面
*/

</script>

</html>